# 镜像与容器

#### Docker镜像

Docker 镜像理解为包含应用程序以及其相关依赖的一个基础文件系统 . 它以只读的方式被用于创建容器的运行环境 .

#### 深入镜像实现

Docker 镜像都是按照 Docker 所设定的逻辑打包 , 受到 Docker Engine 所控制的 . 和虚拟机镜像不同的是 , Docker的镜像我们必须通过 Docker 来打包 , 也必须通过 Docker 下载或导入后使用 , 不能单独直接恢复成容器中的文件系统 .

固定的格式牺牲了灵活性 , 但可以在不同的服务器之间传递Docker镜像 , 配合自带的镜像管理功能 , 传递和共享Docker变得非常方便 .

> 每一个记录文件系统修改的镜像层 , 都会生成一个64位长度的Hash串

在镜像之间共享镜像层 .

![](/assets/jingxiangceng.png)

举一个实际的例子 , 由 Docker 官方提供的两个镜像 elasticsearch 镜像和 jenkins 镜像都是在 openjdk 镜像之上修改而得 , 那么在实际使用的时候 , 这两个镜像是可以共用 openjdk 镜像内部的镜像层的 .

Docker 管理之下的镜像 , 占用空间是以 MB 为单位进行衡量的 , 加之镜像之间还能够共享部分的镜像层 , 也就是共享存储空间 , 所以我们在常见的硬盘里放下几十、数百个镜像也不是什么难事 .

#### 查看镜像

```
docker images
```

**列表包含**

* 仓库名\(REPOSITORY\)
* 标签\(TAG\)
* 镜像ID\(IMAGE ID\) - ID一般只显示64个字符的前12位
* 创建时间\(CREATED\)
* 占用空间\(SIZE\) - 非硬盘实际消耗的体积 , 比实际要小 , 因为多层复用继承的原因 . 

**镜像命名**

虽然镜像ID可以识别唯一性 , 但通过镜像命名识别镜像更容易一些 . REPOSITORY和TAG , 这两者其实就组成了 docker 对镜像的命名规则 .

![](/assets/jingxiangmingming.png)

镜像的命名准确说 , 有三部分 : username , repository , tag

* **username** - 主要用于识别上传镜像的不同用户 , 与 GitHub 中的用户空间类似 . 
* **repository - **主要用于识别进行的内容 , 形成对镜像的表意描述 . 
* **tag - **主要用户表示镜像的版本 , 方便区分进行内容的不同细节 . 

没有**username**的表示镜像是由Docker官方维护和提供的 . **repository**有时候经常采用软件名 , 但其并不是软件 , 而是一个镜像 . 目的是一个容器运行一个程序的 , 及与它运行有关的一些依赖包 .

Docker每次构建镜像的内容也就有所不同 , 具体体现就是镜像层以及它们的 ID 都会产生变化 . 而**tag**标签就是在镜像命名这个层面上区分这些镜像的方法 . 通常用版本号 , 环境等作为tag , 例如redis:3.2 , redis:4.0 , php:7.2-cli , php:7.2-fpm .

还有一个约定 , 在操作中没有具体给出镜像的tag时 , Docker 会采用latest作为缺省 tag . 

