# 镜像

### 获取镜像

```
docker pull [选项] [Docker Registry地址]<仓库名>:<标签>
# 例如,没写Registry地址就从官方下载
docker pull ubuntu:14.04
```

* Docker Registry地址 : 地址的格式一般是`<域名/IP>[:端口号]`.默认地址是 Docker Hub

* 仓库名 : 如之前所说,这里的仓库名是两段式名称,既`<用户名>/<软件名>`.对于Docker Hub,如果不给出用户名,则默认为`library`,也就是官方镜像

下载过程可以看出前面提及的分层存储概念,镜像是由多层存储所构成的.下载过程中给出了每一层的ID前12位.下载结束后给出完整的sha256摘要.

### 运行

运行上面pull的镜像ubuntu:14.04,然后启动里面的bash并且进行交互操作.

```
docker run -it --rm ubuntu:14.04 bash
```

参数详解

* -it : 这里是两个参数,一个是`-i`交互操作,一个是`-t`终端.放在一起的意思是交互式终端
* --rm : 这个参数是说容器退出后随之将其删除.一般情况是不会删除的,一般会手动使用`docker rm`删除.我们现在只是随便测试一下.
* ubuntu:14.04 : 意思是指用ubuntu:14.04镜像为基础来启动容器.
* bash : 放在镜像名后的是命令,bash就是一个交互式shell

查看一下当前系统版本

```
cat /etc/os-release
```

可以看到`Ubuntu 14.04.5 LTS`

最后可以通过`exit`退出

### 列出镜像

列出已经下载的镜像

```
docker images
```

列表包含了仓库名,标签,镜像ID,创建时间,占用空间.

##### 镜像体积

Docker Hub上显示的是镜像压缩后的体积.使用命令docker images列表中的镜像体积也并非硬盘实际消耗的体积,因为Docker镜像是多层存储的,里面有很多继承,复用的关系.所以比实际的要小很多.

##### 虚悬镜像

镜像列表中即没有仓库名,也没有标签名的镜像,是镜像发布了新版本后,重新pull后,新旧镜像同名,旧镜像名称被取消产生的&lt;none&gt;镜像.这种无标签的镜像就是虚悬镜像\(dangling image\).

> docker pull 和 docker build都会导致新旧镜像替换产生的虚悬镜像

```
# 查看虚悬镜像列表
docker images -f dangling=true
```

一般情况下,虚悬镜像已经失去了存在的价值,可以随意删除

```
docker rmi (docker images -q -f dangling=true)
```

##### 中间层镜像

为了加速惊现构建和重复利用资源,Docker会利用中间层镜像作为依赖镜像.使用参数`-a`列出包括所有镜像包括中间层

```
docker images -a
```

这时会列出很多无标签镜像,但有别于虚悬镜像,删除会因为依赖丢失而出错.中间层镜像会随依赖删除而删除.

##### 列出部分镜像

根据仓库名列出镜像

```
docker images ubuntu
```

列出特定的某个镜像\(指定仓库名和标签\)

```
docker images ubuntu:16.04
```

使用过滤器参数`-f(--filter)`过滤镜像

```
# 在mongo:3.2之后建立的镜像
docker images -f since=mongo:3.2
# 查看某个位置之前的镜像
docker images -f before=mongo:3.2
# 还可以通过label过滤镜像列表
docker images -f label=com.example.version=0.1
```

##### 以特定格式显示

显示镜像ID列表

```
docker images -q
```

还可以配合上面提到的`--filter`过滤ID列表

应用Go的模板语法使用`--format`参数自定义列表

```
docker images --format "{{.ID}}: {{.Repository}}"
docker images --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"
```

### 镜像构成

每次执行docker run的时候都会指定镜像作为容器运行基础,可以从Docker Hub上下载镜像使用,也可以自定义定制镜像.

> 镜像和容器都是多层存储,镜像在前一层的基础上修改,容器以镜像为基础.

##### 定制一个Web服务器

```
docker run --name webserver -d -p 80:80 nginx
```

这条命令会用nginx镜像启动一个容器,命名为webserver,并且映射了80端口,这样就可以浏览了.

```
http://localhost
```

想要修改默认的访问页面的文字,需要使用`exec`命令进入容器

```
docker exec -it webserver bash
# 修改一些文字
root@3729b97e8226:/# echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html
root@3729b97e8226:/# exit
exit
```

经过上面的操作,我们改动了容器的文件,也就是容器的存储层.可以使用`docker diff`命令看到具体的改动.

```
doker diff webserver
```

如果现在就是定制好了我们要改变的内容,就可以保存成镜像了.

容器运行时,如果不使用卷,我们做的任何文件修改都会被记录于容器存储层里,而Docker提供了`docker commit`命令,可以将容器的存储层保存下来成为镜像.意思就是在原有镜像的基础上,再叠加上容器的存储层,构成新的镜像.

语法格式:

```
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
```

```
# \是换行符
docker commit \
    --author "Tao Wang <twang2218@gmail.com>" \
    --message "修改了默认网页" \
    webserver \
    nginx:v2
sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214
```

其中--author是指定修改的作者,而--message则是记录本次修改的内容\(和git相似\).

可以在`docker images`中看到新定制的镜像:

```
docker images nginx
# 还可以查看镜像内的历史记录
docker history nginx:v2
```

新的镜像定制好,就可以运行了

```
docker run --name web2 -d -p 81:80 nginx:v2
```

访问`localhost:81`看到记过和`webserver`一样.

##### 慎用docker commit

实际环境中并不会直接使用commit保存分层镜像.使用diff查看镜像区别

```
docker diff webserver
```

会发现除了修改的`/usr/share/nginx/html/index.html`文件外,还有很多被改动或添加的文件.使用commit会添加很多无关的文件到镜像.

使用docker commit意味着所有操作都是黑箱操作,生成的镜像也是黑箱镜像,只有镜像制作的人知道做过什么,维护非常困难.

`docker commit`可以用于被入侵后保存现场等工作,但是定制镜像,还是使用Dockerfile来完成.



